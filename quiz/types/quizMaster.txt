/* Declare dyanmic predicates */
:- dynamic check_answer/3.
:- dynamic participants/1.
:- dynamic game_state/1.
:- dynamic asked_questions/1.
:- dynamic not_answered/1.
:- dynamic current_question/1.

:- write('Master agent loading...'), nl.

/* Initialize Available Quiz Questions */
question(question1).
question(question2).
question(question3).
question(question4).
question(question5).
question(question6).
question(question7).
question(question8).
question(question9).
question(question10).
:- write('Questions loaded.'), nl.

/* Initialize Available Quiz Answers */
answer(answer1).
answer(answer2).
answer(answer3).
answer(answer4).
answer(answer5).
answer(answer6).
answer(answer7).
answer(answer8).
answer(answer9).
answer(answer10).
:- write('Answers loaded.'), nl.

/* Initialize Correct Quiz Correspondences */
correct(question1,answer1).
correct(question2,answer2).
correct(question3,answer3).
correct(question4,answer4).
correct(question5,answer5).
correct(question6,answer6).
correct(question7,answer7).
correct(question8,answer8).
correct(question9,answer9).
correct(question10,answer10).
:- write('Correspondences loaded.'), nl.

/* Initialize Constant Predicates 
    - Notary Agent Name       */
notary(notary).

/* Initialize Dynamic Predicates */
participants([]).
game_state(waiting).
asked_questions([]).
current_question(none).

/* Declare Auxiliary Predicates */
correct_answer(Q,A) :- question(Q), answer(A), correct(Q,A).
available_questions(L) :- findall(Q, question(Q), L).
send_to_all([],_,_).
send_to_all([A|T], Event, From) :- messageA(A,send_message(Event, From)),
                               send_to_all(T, Event, From), 
                               write('Event sent to '),
                               write(A),
                               write(' as '),
                               write(Event),
                               write(' from '),
                               write(From).
subtract_questions([],_,[]).
subtract_questions([H|T],L2,R) :- member(H,L2), subtract_questions(T,L2,R).
subtract_questions([H|T],L2,[H|R]) :- \+ member(H,L2), subtract_questions(T,L2,R). 

/* Ask Questions to All Participants */
ask_questionE(L) :> agent(Me),
            participants(Participants),
            retract(participants(Participants)),
            assert(participants(L)),
            available_questions(Questions),
            asked_questions(Asked),
            subtract_questions(Questions, Asked, Remaining),
            random_member(Q, Remaining),
            retract(asked_questions(Asked)),
            assert(asked_questions([Q|Asked])),
            assert(not_answered(Q)),
            retract(current_question(_)),
            assert(current_question(Q)),
            write('Ask question '),
            write(Q),
            write(' to competitors '),
            write(L), nl,
            send_to_all(L, ask(Q), Me).

/* Check Answers Correctness */
answer_questionE(Q,A,P) :> current_question(Q), not_answered(Q), check_answerA(Q,A,P).
answer_questionE(Q,A,P) :> current_question(Q), \+ not_answered(Q), write('Question already answered. Wait for next question.').

check_answer(Q,A,P) :< correct_answer(Q,A),
                    retract(not_answered(Q)),
                    write('Answer of '),
                    write(P),
                    write(' is correct!'), nl,
                    notary(N),
                    agent(Me),
                    messageA(N, send_message(update(P),Me)),
                    messageA(P, send_message(correct_answer(Q,A),Me)).

check_answer(Q,A,P) :< \+ correct_answer(Q,A),
                    write('Answer of '),
                    write(P),
                    write(' is wrong!'), nl,
                    messageA(P, send_message(wrong_answer(A),Me)).

/* End Game Notifying Winner and Other Players */
end_gameE(A) :> write('Game is finished. Winner is '),
                write(A),
                agent(Me),
                participants(L),
                send_to_all(L,end(A),Me),
                retract(game_state(_)),
                assert(game_state(finished)).

/* Sleep Infinitely when Game Ends */
game_stateI(finished) :> write('Game is over. Sleeping forever.'),
                         sleep(10000000000000000). 